---
title: 是否应该追求100%的测试覆盖
excerpt: "相信很多人对此都有自己的答案。在这里，我想换个角度来阐述一下对测试覆盖的看法。"
categories: [tech]
tags: [agile, code-quality]
---

相信很多人在看到这个问题时，其实心里都是有一致否定的答案的。或者说，这个问题更应该是一个反问，而非疑问。但是在这里，我想从另一个角度出发，来阐述一下我对测试覆盖的一些看法。

首先，不可否认的一个事实是，在软件开发中，任何一行看似不会有问题的代码，没准就会出问题，有所不同的，只是问题的严重程度。在我过去接触的项目中，有一个例子记忆犹新。一行看似普通的代码，最终却在部署环境里导致了OutOfMemory的致命错误。而这一点，所有人事前都没有察觉到。因为那一行代码实在是简单的不能再简单了。因为任何一行代码都可能出现问题，所以原则上，有问题的代码就有测试的必要。这看起来似乎是一个很合理的因果关系。

其次，在当下日益强调的高质量持续集成和持续交付（即CI/CD）的大背景下，将这种测试从人工变成充分的自动测试也是很有必要的。想象一下我们身处这样的场景：在公有云环境里，你的代码在提交之后，经过短则数小时，多则一天的时间，就会被部署到真实的生产环境中去，对系统运行产生一定的影响（不要被feature toggle这样的技术所迷惑，因为要实现feature toggle，本身就需要代码来支持，是代码就有可能出错）。又比如：在私有云环境里，我们有服务于不同客户的多个部署环境同时存在。为了降低维护成本，我们摒弃了多分支的开发模式，而只保留代码库的主分支。此时，充分的自动化回归测试就很有必要了。否则，为了解决某位客户的问题所交付的代码，就可能比以往任何时候都更容易影响到其它客户，因为不会再有多分支为我们提供“掩护”了。

综合前面所说的两点，我们可以得出这样的结论：

> 原则上，任何一行代码都是需要自动化测试的。

行文至此，也许各位已经看出来了，前面所讲的，核心思想无非是在强调自动化测试和测试覆盖的重要性。这个道理大家都认可，但实际操作时却常常会倍感为难。所谓理想是美好的，现实是骨感的。这也是为什么我加了“原则上”作为修饰语的原因。别急，接下来的内容才是本文的重点:-)

当我们考虑到现实情况，通常遇到的一个典型的困难是：如果有一行代码很难覆盖到，怎么办呢？这里其实本质上是一个投入产出比的问题（或者说成本问题）。而且，这个投入产出比是因人而异的，甚至，即使是同一个人，随着技能的改变，成本也会有所不同。所以，相比于“是否应该追求100%的测试覆盖”这样的问题，“当保持现有测试覆盖率的成本对我而言很大时，该怎么办？”，这样的问题其实更具有现实意义。需要着重指出我在这里所用的措辞：

* 此处并没有使用“保持100%测试覆盖率”这样的说法，因为在我看来，如果新引入的代码可能会导致测试覆盖的降低，且避免降低的成本很高，无论当前的测试覆盖是100%，还是50%，都是一样的。甚至当前为100%时，我们所面对的境遇可能会更好一些，因为测试覆盖率越低，你所要承担的，先前遗留下来的技术债就会越高，要维持测试覆盖不变甚至增长所付出的成本可能会更高。对此我是深有体会的，记得几年前的一个项目中，我花费了大把的精力，废寝忘食的将一个遗留系统的整套单元测试几乎重写，带来的测试覆盖率的提升也就区区4到5个百分点而已——从36%升到了41%。
* 此处有意使用了第一人称“我”，是想再次强调，这种成本是相对的，因人而异，因时而异。

很多人也正是因为在这里遇到了成本问题，所以即使充分认可原则，也依然会有所疑虑，于是就会提出本文开篇的那个问题。的确如此，成本从来都是一个不可忽视的因素，这一点很多人都非常认可，尤其对管理者而言，更为敏感。只是对于这一点，我想换个角度，从“机遇”的角度出发，来谈一谈我的一些看法。

当我们很难做到保持现有测试覆盖的时候，无论现有覆盖是100%，还是50%，总之是要不可避免的下降了，此时，我们不妨先别急着提出“是否应该追求100%的测试覆盖”这样一个似乎有着明确的隐含答案的问题，或者说通过提出这一问题，很快就“理所当然”的“缴械投降”了。相反地，我们不妨先想一想另外一些问题，比如：

* 这行代码是否真的有存在的必要呢？如果我怎么做都无法覆盖到它的话，也许，没有一个在真实场景下出现的输入条件可以触发这行代码的执行，那么在真实环境里，它可能就是永远都没有机会被执行的。这样的代码是不是可以痛痛快快的删掉呢？
* 这行代码很难测到，是否意味着我们的代码在设计上存在问题呢？是否意味着我们应该调整我们的代码结构呢？测试很难覆盖，有时没准真的就是代码质量问题与代码结构问题的一种“坏味道”——这是一种提醒我们应该好好考虑一下代码中潜在问题的有益信号。多年以前在Java世界里，伴随着Spring框架的风靡，所谓的IoC以及Dependency Injection思想其实就是一个极好的例子。以Spring为代表的IoC容器对传统以EJB为代表的软件设计架构上的颠覆与革新，使我们对于如何通过合理的软件设计与架构，让测试代码更易于编写有了新的认识。
* 如果我再花一点时间仔细想一想，或者在网上查一查，或者问一问其它的同事，也许就能找到测试这行代码的办法，说不定我的开发技能就会因此而有所提升呢？比如，通过Google，我了解到一些开源的基于Node.Js的mock测试框架，引入这些框架就可以解决测试覆盖的问题。

不知大家有没有注意到，上面每一个问题里，其实都蕴含着“机遇”，也许我们不必很快地放弃努力，因为那样也许我们就失去了一个机会：

* 一个让我们清除无用代码的机会
* 一个让代码变得结构更合理，质量更高的机会
* 一个让我们的开发人员在软件开发经验上获得提升的机会

“机遇”是一种“投资”，一种对产品，对团队，对个人而言的投资。它也许不是短期的，而是长期的；也许不是局部的，而是更大范围的；也许不是单纯用钱来衡量的，而是包含其它价值因素的。看重前者而忽视后者，不可以说绝对的错，它不过是团队或者个人在价值取向与行事风格上的一种多样性的体现。当然，既然是投资，那么在有可观回报的同时，也免不了有风险。这就要看团队与个人的取舍了。

最后，如果经过考量，觉得还是放弃保持现有覆盖率不下降这样的决定更优。那也可以大胆地去做，只是团队或者个人需要清楚并且承担这一决定所带来的结果意味着什么。

总结一下，首先，判断是否保持现有覆盖率不下降，从来不是根据测试是否难写来判断的，而是根据测试是否有实际意义而定的。其次，如果测试有意义，但又代价高昂，那就需要做出权衡和取舍。在这样的情况下，团队或者个人的价值取向决定了我们的选择。我个人的建议是，从“机遇”的角度来看待这个问题，也许这就是一个“机遇”，一个“信号”：也许我们的技能需要提高，也许代码的结构需要提高（让它变得更加易于测试）。我们不妨把它看做是一个有益的信号，无视这个信号就意味着失去了一次改进代码或提高自身的机会，同时也增加了技术债，以及随之而来的隐患，隐患也许未必就一定是以产品缺陷的形式立即暴露出来，也许它永远都不会暴露，或者等它暴露时，我们已经不在其位了;-)
